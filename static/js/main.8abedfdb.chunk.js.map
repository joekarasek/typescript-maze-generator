{"version":3,"sources":["lib/cell.ts","lib/squareMaze.ts","lib/pathGenerators.ts","components/SquareMazeView.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Cell","row","col","links","neighbors","pathWeight","this","north","east","west","south","cell","relation","indexOf","push","link","indexOfCell","splice","unlink","queryCell","keys","index","Math","floor","random","hasSouthWall","isLinked","hasNorthWall","hasEastWall","hasWestWall","SquareMaze","rows","cols","cells","maxPathWeight","buildCells","setAllCellNeighbors","i","j","setSingleCellNeighbors","getCell","addNeighbor","randomRow","randomCol","flatMap","getAll","length","map","RowOfCells","getCellRenderData","method","maze","sample","unvisitedCells","size","computationalSteps","neighbor","sampleNeighbor","console","log","aldousBroder","param","forEach","run","atEasternEdge","atNorthernEdge","sideWinder","choices","choice","blackList","includes","targetCell","starterCell","clearAllPathWeights","setDijkstra","breadCrumbs","currentCell","rootCell","frontier","newMaxWeight","newFrontier","linkedCell","newFrontierWeight","SquareMazeView","renderData","className","rowIndex","key","cellIndex","classes","classNames","App","useState","renderMethod","setRenderMethod","newMaze","buildPaths","topLeftCell","bottomRightCell","findPath","getRenderData","onClick","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.8abedfdb.chunk.js","sourcesContent":["type RelationshipPossibilities = \"north\" | \"south\" | \"east\" | \"west\";\n\nexport interface CellRenderData {\n    hasNorthWall: boolean;\n    hasSouthWall: boolean;\n    hasEastWall: boolean;\n    hasWestWall: boolean;\n    pathWeight: number | null;\n}\n\nexport default class Cell {\n    row: number;\n    col: number;\n    links: Cell[];\n    neighbors: {\n        north: null | Cell,\n        east: null | Cell,\n        west: null | Cell,\n        south: null | Cell\n    };\n    pathWeight: number | null;\n\n    constructor(row: number, col: number) {\n        this.row = row;\n        this.col = col;\n        this.links = [];\n        this.neighbors = {\n            north: null,\n            east: null,\n            west: null,\n            south: null\n        };\n        this.pathWeight = null;\n    }\n\n    addNeighbor(cell: Cell | null, relation: RelationshipPossibilities): void {\n        this.neighbors[relation] = cell;\n    }\n\n    link(cell: Cell | null): void {\n        if (cell && this.links.indexOf(cell) === -1) {\n            this.links.push(cell);\n            cell.link(this);\n        }\n    }\n\n    unlink(cell: Cell): void {\n        const indexOfCell: number = this.links.indexOf(cell);\n        if (indexOfCell >= 0) {\n            this.links.splice(indexOfCell, 1);\n            cell.unlink(this);\n        }\n    }\n\n    isLinked(queryCell: Cell | null): boolean {\n        if (queryCell) {\n            return this.links.indexOf(queryCell) !== -1;\n        }\n        return false;\n    }\n\n    // @todo refactor, as this assumes there is a neighborCell to sample and could loop forever if no neighbors are set\n    sampleNeighbor(): Cell | null {\n        const keys: RelationshipPossibilities[] = ['north','east','south','west'];\n        let index: number = -1;\n        do {\n            index = Math.floor(Math.random() * 4);\n        } while (!this.neighbors[keys[index]]);\n        return this.neighbors[keys[index]];\n    }\n\n    getCellRenderData(): CellRenderData {\n        return {\n            hasSouthWall: !this.isLinked(this.neighbors['south']),\n            hasNorthWall: !this.isLinked(this.neighbors['north']),\n            hasEastWall: !this.isLinked(this.neighbors['east']),\n            hasWestWall: !this.isLinked(this.neighbors['west']),\n            pathWeight: this.pathWeight,\n        }\n    }\n}\n","import Cell, { CellRenderData } from './cell';\nimport { binaryTree, aldousBroder, sideWinder } from './pathGenerators';\nimport {start} from \"repl\";\n\nexport default class SquareMaze {\n    rows: number;\n    cols: number;\n    cells: Cell[][];\n    maxPathWeight: number | null;\n\n    constructor(rows: number, cols: number) {\n        this.rows = rows;\n        this.cols = cols;\n        this.cells = [];\n        this.buildCells();\n        this.setAllCellNeighbors();\n        this.maxPathWeight = null;\n    }\n\n    private buildCells(): void {\n        for (let i: number = 0; i < this.rows; i++) {\n            this.cells.push([]);\n            for (let j: number = 0; j < this.cols; j++) {\n                this.cells[i][j] = new Cell(i, j);\n            }\n        }\n    }\n\n    private setAllCellNeighbors(): void {\n        for (let i: number = 0; i < this.rows; i++) {\n            for (let j: number = 0; j < this.cols; j++) {\n                // Set's neighbors for each cell. Note: this function is subclassed to allow future modifications\n                this.setSingleCellNeighbors(this.getCell(i,j));\n            }\n        }\n    };\n\n    private setSingleCellNeighbors(cell: Cell | null): void {\n        if (!cell) return;\n        const row = cell.row;\n        const col = cell.col;\n\n        cell.addNeighbor(this.getCell(row-1, col), 'north');\n        cell.addNeighbor(this.getCell(row, col-1), 'west');\n        cell.addNeighbor(this.getCell(row+1, col), 'south');\n        cell.addNeighbor(this.getCell(row, col+1), 'east');\n    }\n\n    getCell(row: number, col: number): Cell | null {\n        return (this.cells[row] && this.cells[row][col]) || null;\n    }\n\n    sample(): Cell | null {\n        const randomRow: number = Math.floor((Math.random() * this.rows));\n        const randomCol: number = Math.floor((Math.random() * this.cols));\n        return this.getCell(randomRow, randomCol);\n    };\n\n    getRow(row: number): Cell[] | null {\n        return this.cells[row] || null;\n    };\n\n    getAll(): Cell[] {\n        return this.cells.flatMap(cell => cell);\n    };\n\n    size(): number {\n        return this.getAll().length;\n    };\n\n    getRenderData(): CellRenderData[][] {\n        return this.cells.map(RowOfCells => RowOfCells.map( cell => cell.getCellRenderData()));\n    };\n\n    buildPaths(method: string) {\n        switch(method) {\n            case 'Aldous Broder':\n                aldousBroder(this);\n                break;\n            case 'side winder':\n                sideWinder(this);\n                break;\n            case 'binary tree':\n            default:\n                binaryTree(this);\n                break;\n        }\n    };\n\n    clearAllPathWeights(blackList: Cell[] = []): void {\n        this.cells.forEach(row => row.forEach(cell => {\n            if (!blackList.includes(cell)) {\n                cell.pathWeight = null\n            }\n        }));\n    };\n\n    findPath(targetCell: Cell | null, starterCell: Cell | null): void {\n        if (!targetCell || !starterCell) return;\n        this.clearAllPathWeights();\n        this.setDijkstra(targetCell);\n\n        const breadCrumbs: Cell[] = [starterCell];\n        let currentCell = starterCell;\n        while (currentCell !== targetCell) {\n            currentCell.links.forEach(cell => {\n                // @ts-ignore\n                if (cell.pathWeight < currentCell.pathWeight) {\n                    breadCrumbs.push(cell);\n                    currentCell = cell;\n                }\n            })\n        }\n\n        this.clearAllPathWeights(breadCrumbs);\n    }\n\n    setDijkstra(rootCell: Cell | null): void {\n        if (!rootCell) return;\n        rootCell.pathWeight = 1;\n        let frontier: Cell[] = [rootCell];\n        let newMaxWeight = 1;\n\n        while (frontier.length > 0) {\n            let newFrontier: Cell[] = [];\n\n            frontier.forEach((cell) => {\n                cell.links.forEach((linkedCell) => {\n                    if (linkedCell.pathWeight === null) {\n                        // @ts-ignore\n                        let newFrontierWeight: number = cell.pathWeight + 1;\n                        linkedCell.pathWeight = newFrontierWeight;\n                        newFrontier.push(linkedCell);\n                        newMaxWeight = newFrontierWeight;\n                    }\n                });\n            });\n            frontier = newFrontier;\n        }\n        this.maxPathWeight = newMaxWeight;\n    };\n\n\n}\n","import Cell from './cell';\nimport SquareMaze from './squareMaze';\n\nexport const binaryTree = (maze: SquareMaze) => {\n    maze.getAll().forEach(function(cell) {\n        const choices = [];\n        if (cell.neighbors.north) {\n            choices.push(cell.neighbors.north);\n        }\n        if (cell.neighbors.east) {\n            choices.push(cell.neighbors.east);\n        }\n\n        if (choices.length>0) {\n            const choice = choices[ Math.floor((Math.random() * choices.length)) ];\n            cell.link(choice);\n        }\n\n    });\n};\n\nexport const aldousBroder = (maze: SquareMaze) => {\n    let cell = maze.sample();\n    let unvisitedCells = maze.size() - 1;\n    let computationalSteps = 1;\n\n    while (unvisitedCells > 0 && computationalSteps < 25000) {\n        let neighbor = cell && cell.sampleNeighbor();\n\n        if (neighbor && neighbor.links.length === 0) {\n            // @ts-ignore\n            cell.link(neighbor);\n            unvisitedCells--;\n        }\n\n        cell = neighbor;\n        computationalSteps ++;\n    }\n    console.log(`Aldous Broder maze generation visited ${computationalSteps} cells before visiting all cells and completing`);\n};\n\nexport const sideWinder = (maze: SquareMaze, param: number = 0.5) => {\n    maze.cells.forEach((row: Cell[] ) => {\n        let run: Cell[] = [];\n\n        row.forEach(function(cell) {\n            run.push(cell);\n\n            let atEasternEdge = (cell.neighbors.east === null);\n            let atNorthernEdge = (cell.neighbors.north === null);\n            let shouldCloseRun = atEasternEdge || (!atNorthernEdge && Math.random() < param);\n\n            if (shouldCloseRun) {\n                let index = Math.floor(Math.random() * run.length);\n                if (run[index].neighbors.north) {\n                    run[index].link(run[index].neighbors.north);\n                }\n                run = [];\n            } else {\n                cell.link(cell.neighbors.east);\n            }\n        });\n    });\n};\n","import React, {ReactElement} from 'react';\nimport classNames from 'classnames';\nimport { CellRenderData } from '../lib/cell';\n\ninterface SquareMazeViewProps {\n    renderData: CellRenderData[][];\n}\n\nexport default function SquareMazeView({renderData}: SquareMazeViewProps): ReactElement {\n    return (\n        <div className=\"square-maze\">\n            {renderData.map((row, rowIndex) =>(\n                <div key={`row-${rowIndex}`} className=\"square-maze__row\">\n                    {row.map((cell, cellIndex) => {\n                        const classes = classNames(\"square-maze__cell\", {\n                            \"square-maze__cell--has-north-wall\": cell.hasNorthWall,\n                            \"square-maze__cell--has-south-wall\": cell.hasSouthWall,\n                            \"square-maze__cell--has-east-wall\": cell.hasEastWall,\n                            \"square-maze__cell--has-west-wall\": cell.hasWestWall,\n                        });\n                        return (\n                            <div key={`cell-${cellIndex}-${rowIndex}`} className={classes}>\n                                {cell.pathWeight || ' '}\n                            </div>\n                        );\n                    })}\n                </div>\n            ))}\n        </div>\n    );\n}\n\nSquareMazeView.propTypes = {};\n","import React, { useState } from 'react';\nimport SquareMaze from './lib/squareMaze';\nimport SquareMazeView from './components/SquareMazeView';\nimport './App.css';\n\nfunction App() {\n  const [ renderMethod, setRenderMethod ] = useState('binary tree');\n  const newMaze = new SquareMaze(30,30);\n  newMaze.buildPaths(renderMethod);\n  const topLeftCell = newMaze.getCell(0, 0);\n  const bottomRightCell = newMaze.getCell(29, 29);\n  newMaze.findPath(topLeftCell, bottomRightCell);\n  // newMaze.setDijkstra(topLeftCell);\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <SquareMazeView renderData={newMaze.getRenderData()} />\n          <div className=\"buttons\">\n              <button onClick={() => setRenderMethod('Aldous Broder')}>Aldous Broder</button>\n              <button onClick={() => setRenderMethod('binary tree')}>Binary Tree</button>\n              <button onClick={() => setRenderMethod('side winder')}>Side Winder</button>\n          </div>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}